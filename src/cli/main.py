"""Command-line interface for the video transcription pipeline."""

import argparse
import signal
import sys
from pathlib import Path

from src.core.config import PipelineConfig
from src.core.exceptions import VideoTranscriptionError
from src.core.pipeline import VideoTranscriptionPipeline
from src.utils.ui_utils import ColorFormatter, StatusReporter


class VideoTranscriptionCLI:
    """Command-line interface for video transcription pipeline."""

    def __init__(self):
        self.pipeline = None
        self.status_reporter = None
        self._setup_signal_handlers()

    def _setup_signal_handlers(self):
        """Setup signal handlers for graceful shutdown."""
        def signal_handler(signum, frame):
            # Ignore subsequent signals
            signal.signal(signal.SIGINT, signal.SIG_IGN)
            print(ColorFormatter.error("\n\n[INFO] Interrupted by user. Cleaning up and exiting..."))
            sys.exit(0)

        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)

    def create_parser(self) -> argparse.ArgumentParser:
        """Create command-line argument parser."""
        parser = argparse.ArgumentParser(
            description="Process videos, audio, text, and images into study materials and PDFs",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog="""
Examples:
  %(prog)s /path/to/media/folder                    # Process with default settings
  %(prog)s /path/to/media --no-pdf                  # Skip PDF generation
  %(prog)s /path/to/media --llm-model llama2        # Use different LLM model
  %(prog)s /path/to/media --verbose                  # Show detailed progress
  %(prog)s /path/to/media --output-dir /output      # Specify output directory
            """
        )

        # Positional arguments
        parser.add_argument(
            "directory",
            type=Path,
            help="Path to folder containing media files to process"
        )

        # Processing options
        parser.add_argument(
            "--no-pdf",
            action="store_true",
            help="Skip PDF generation (PDF generated by default)"
        )

        parser.add_argument(
            "--no-ai-marking",
            action="store_true",
            help="Disable AI content marking (watermark, attribution, acknowledgment)"
        )

        parser.add_argument(
            "--output-dir",
            type=Path,
            help="Output directory for generated files (default: same as input)"
        )

        # Model options
        parser.add_argument(
            "--whisper-model",
            default="medium",
            choices=["tiny", "base", "small", "medium", "large", "large-v2", "large-v3"],
            help="Whisper model size for transcription (default: medium)"
        )

        parser.add_argument(
            "--llm-model",
            default="gemma3",
            help="LLM model for content generation (default: gemma3)"
        )

        # UI options
        parser.add_argument(
            "--verbose", "-v",
            action="store_true",
            help="Show detailed progress information"
        )

        parser.add_argument(
            "--no-spinner",
            action="store_true",
            help="Disable progress spinner"
        )

        # Validation options
        parser.add_argument(
            "--check-deps",
            action="store_true",
            help="Check dependencies and exit"
        )

        parser.add_argument(
            "--validate-only",
            action="store_true",
            help="Validate input files and exit without processing"
        )

        # Configuration options
        parser.add_argument(
            "--config",
            type=Path,
            help="Path to configuration file (JSON format)"
        )

        return parser

    def parse_config_file(self, config_path: Path) -> dict:
        """Parse configuration file."""
        import json

        try:
            with open(config_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(ColorFormatter.error(f"Failed to parse config file {config_path}: {e}"))
            sys.exit(1)

    def create_config(self, args) -> PipelineConfig:
        """Create configuration from command-line arguments."""
        # Start with default config
        config_dict = {}

        # Load config file if provided
        if args.config:
            config_dict = self.parse_config_file(args.config)

        # Override with command-line arguments
        config_dict.update({
            "generate_pdf": not args.no_pdf,
            "enable_ai_marking": not args.no_ai_marking,
            "whisper_model": args.whisper_model,
            "llm_model": args.llm_model,
            "verbose": args.verbose,
            "show_spinner": not args.no_spinner,
        })

        if args.output_dir:
            config_dict["output_dir"] = args.output_dir

        try:
            return PipelineConfig(**config_dict)
        except Exception as e:
            print(ColorFormatter.error(f"Configuration error: {e}"))
            sys.exit(1)

    def check_dependencies(self, config: PipelineConfig) -> bool:
        """Check if all dependencies are available."""
        print(ColorFormatter.info("Checking dependencies..."))

        all_good = True

        # Check Whisper availability
        try:
            import whisper
            print(ColorFormatter.success("✓ Whisper available"))
        except ImportError:
            print(ColorFormatter.error("✗ Whisper not available - install with: pip install openai-whisper"))
            all_good = False

        # Check Tesseract availability
        try:
            import pytesseract
            print(ColorFormatter.success("✓ Tesseract OCR available"))
        except ImportError:
            print(ColorFormatter.error("✗ Tesseract not available - install with: pip install pytesseract"))
            all_good = False

        # Check PIL availability
        try:
            from PIL import Image
            print(ColorFormatter.success("✓ PIL/Pillow available"))
        except ImportError:
            print(ColorFormatter.error("✗ PIL not available - install with: pip install Pillow"))
            all_good = False

        # Check LangChain availability
        try:
            from langchain_core.prompts import PromptTemplate
            from langchain_ollama import OllamaLLM
            print(ColorFormatter.success("✓ LangChain available"))
        except ImportError:
            print(ColorFormatter.error("✗ LangChain not available - install with: pip install langchain-core langchain-ollama"))
            all_good = False

        # Check Pandoc availability
        import subprocess
        try:
            subprocess.run(["pandoc", "--version"], check=True, capture_output=True)
            print(ColorFormatter.success("✓ Pandoc available"))
        except (subprocess.CalledProcessError, FileNotFoundError):
            print(ColorFormatter.warning("⚠ Pandoc not available - PDF generation will fail"))
            if config.generate_pdf:
                print(ColorFormatter.warning("  Use --no-pdf to skip PDF generation"))

        # Check LaTeX engines
        latex_engines = ["xelatex", "pdflatex"]
        latex_found = False
        for engine in latex_engines:
            try:
                subprocess.run([engine, "--version"], check=True, capture_output=True)
                print(ColorFormatter.success(f"✓ {engine} available"))
                latex_found = True
                break
            except (subprocess.CalledProcessError, FileNotFoundError):
                continue

        if not latex_found:
            print(ColorFormatter.warning("⚠ No LaTeX engine found - PDF generation will fail"))
            if config.generate_pdf:
                print(ColorFormatter.warning("  Use --no-pdf to skip PDF generation"))

        return all_good

    def validate_input_directory(self, directory: Path) -> bool:
        """Validate input directory."""
        if not directory.exists():
            print(ColorFormatter.error(f"Directory not found: {directory}"))
            return False

        if not directory.is_dir():
            print(ColorFormatter.error(f"Path is not a directory: {directory}"))
            return False

        return True

    def run(self, args=None):
        """Run the CLI application."""
        parser = self.create_parser()
        args = parser.parse_args(args)

        # Create configuration
        config = self.create_config(args)
        self.status_reporter = StatusReporter(config.verbose)

        # Check dependencies if requested
        if args.check_deps:
            deps_ok = self.check_dependencies(config)
            sys.exit(0 if deps_ok else 1)

        # Validate input directory
        if not self.validate_input_directory(args.directory):
            sys.exit(1)

        # Validate only mode
        if args.validate_only:
            print(ColorFormatter.info("Validating input files..."))
            # TODO: Implement file validation
            print(ColorFormatter.success("Validation complete"))
            sys.exit(0)

        # Initialize pipeline
        try:
            self.pipeline = VideoTranscriptionPipeline(config)

            # Validate prerequisites
            validation = self.pipeline.validate_prerequisites()

            if not validation.get("overall_ready", False):
                print(ColorFormatter.error("Prerequisites not met:"))
                for key, value in validation.items():
                    if key != "overall_ready" and not value:
                        print(ColorFormatter.error(f"  ✗ {key}"))
                sys.exit(1)

        except VideoTranscriptionError as e:
            print(ColorFormatter.error(f"Pipeline initialization failed: {e}"))
            sys.exit(1)

        # Start processing
        try:
            print(ColorFormatter.info("AI is warming up... ready to crunch some knowledge."))

            # Process directory
            result = self.pipeline.process_directory(args.directory)

            if result.success:
                print(ColorFormatter.success(f"\nProcessing completed successfully!"))
                if config.verbose:
                    print(f"Message: {result.message}")
                    if result.metadata:
                        print(f"Metadata: {result.metadata}")
            else:
                print(ColorFormatter.error(f"\nProcessing completed with errors."))
                print(f"Message: {result.message}")
                sys.exit(1)

        except KeyboardInterrupt:
            # Handled by signal handler
            pass
        except VideoTranscriptionError as e:
            print(ColorFormatter.error(f"Processing failed: {e}"))
            sys.exit(1)
        except Exception as e:
            print(ColorFormatter.error(f"Unexpected error: {e}"))
            if config.verbose:
                import traceback
                traceback.print_exc()
            sys.exit(1)


def main():
    """Main entry point for the CLI."""
    cli = VideoTranscriptionCLI()
    cli.run()


if __name__ == "__main__":
    main()
